// Package CowinPublicV2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package CowinPublicV2

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for CenterResponseSchemaFeeType.
const (
	CenterResponseSchemaFeeTypeFree CenterResponseSchemaFeeType = "Free"

	CenterResponseSchemaFeeTypePaid CenterResponseSchemaFeeType = "Paid"
)

// Defines values for SessionCalendarEntrySchemaFeeType.
const (
	SessionCalendarEntrySchemaFeeTypeFree SessionCalendarEntrySchemaFeeType = "Free"

	SessionCalendarEntrySchemaFeeTypePaid SessionCalendarEntrySchemaFeeType = "Paid"
)

// CenterResponseSchema defines model for CenterResponseSchema.
type CenterResponseSchema struct {
	Address *string `json:"address,omitempty"`

	// Address line in preferred language as specified in Accept-Language header parameter.
	AddressL  *string `json:"address_l,omitempty"`
	BlockName string  `json:"block_name"`

	// Block name in preferred language as specified in Accept-Language header parameter.
	BlockNameL   *string `json:"block_name_l,omitempty"`
	CenterId     float32 `json:"center_id"`
	DistrictName string  `json:"district_name"`

	// District name in preferred language as specified in Accept-Language header parameter.
	DistrictNameL *string `json:"district_name_l,omitempty"`

	// Fee charged for vaccination
	FeeType CenterResponseSchemaFeeType `json:"fee_type"`
	From    string                      `json:"from"`
	Lat     *float32                    `json:"lat,omitempty"`
	Long    *float32                    `json:"long,omitempty"`
	Name    string                      `json:"name"`

	// Name in preferred language as specified in Accept-Language header parameter.
	NameL     *string `json:"name_l,omitempty"`
	Pincode   string  `json:"pincode"`
	StateName string  `json:"state_name"`

	// State name in preferred language as specified in Accept-Language header parameter.
	StateNameL *string `json:"state_name_l,omitempty"`
	To         string  `json:"to"`
}

// Fee charged for vaccination
type CenterResponseSchemaFeeType string

// SessionCalendarEntriesSchema defines model for SessionCalendarEntriesSchema.
type SessionCalendarEntriesSchema []SessionCalendarEntrySchema

// SessionCalendarEntrySchema defines model for SessionCalendarEntrySchema.
type SessionCalendarEntrySchema struct {
	Address *string `json:"address,omitempty"`

	// Address line in preferred language as specified in Accept-Language header parameter.
	AddressL  *string `json:"address_l,omitempty"`
	BlockName string  `json:"block_name"`

	// Block name in preferred language as specified in Accept-Language header parameter.
	BlockNameL   *string `json:"block_name_l,omitempty"`
	CenterId     float32 `json:"center_id"`
	DistrictName string  `json:"district_name"`

	// District name in preferred language as specified in Accept-Language header parameter.
	DistrictNameL *string `json:"district_name_l,omitempty"`

	// Fee charged for vaccination
	FeeType SessionCalendarEntrySchemaFeeType `json:"fee_type"`
	From    string                            `json:"from"`
	Lat     *float32                          `json:"lat,omitempty"`
	Long    *float32                          `json:"long,omitempty"`
	Name    string                            `json:"name"`

	// Name in preferred language as specified in Accept-Language header parameter.
	NameL    *string `json:"name_l,omitempty"`
	Pincode  string  `json:"pincode"`
	Sessions []struct {
		AvailableCapacity float32 `json:"available_capacity"`
		Date              string  `json:"date"`
		MinAgeLimit       float32 `json:"min_age_limit"`
		SessionId         string  `json:"session_id"`

		// Array of slot names
		Slots   []string `json:"slots"`
		Vaccine string   `json:"vaccine"`
	} `json:"sessions"`
	StateName string `json:"state_name"`

	// State name in preferred language as specified in Accept-Language header parameter.
	StateNameL  *string               `json:"state_name_l,omitempty"`
	To          string                `json:"to"`
	VaccineFees *VaccineFeeListSchema `json:"vaccine_fees,omitempty"`
}

// Fee charged for vaccination
type SessionCalendarEntrySchemaFeeType string

// SessionResponseSchema defines model for SessionResponseSchema.
type SessionResponseSchema struct {
	// Embedded struct due to allOf(#/components/schemas/CenterResponseSchema)
	CenterResponseSchema `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	AvailableCapacity float32 `json:"available_capacity"`
	Date              string  `json:"date"`
	Fee               string  `json:"fee"`
	MinAgeLimit       float32 `json:"min_age_limit"`
	SessionId         string  `json:"session_id"`

	// Array of slot names
	Slots   []string `json:"slots"`
	Vaccine string   `json:"vaccine"`
}

// SessionsSchema defines model for SessionsSchema.
type SessionsSchema []SessionResponseSchema

// VaccineFeeListSchema defines model for VaccineFeeListSchema.
type VaccineFeeListSchema []VaccineFeeSchema

// VaccineFeeSchema defines model for VaccineFeeSchema.
type VaccineFeeSchema struct {
	Fee     string `json:"fee"`
	Vaccine string `json:"vaccine"`
}

// DistrictsParams defines parameters for Districts.
type DistrictsParams struct {

	// The locate code of the preferred language such as en_US. The text data will be returned in the preferred language along with default English text.
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// StatesParams defines parameters for States.
type StatesParams struct {

	// The locate code of the preferred language such as en_US. The text data will be returned in the preferred language along with default English text.
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// CalendarByDistrictParams defines parameters for CalendarByDistrict.
type CalendarByDistrictParams struct {
	DistrictId string `json:"district_id"`
	Date       string `json:"date"`

	// The locate code of the preferred language such as en_US. The text data will be returned in the preferred language along with default English text.
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// CalendarByPinParams defines parameters for CalendarByPin.
type CalendarByPinParams struct {
	Pincode string `json:"pincode"`
	Date    string `json:"date"`

	// The locate code of the preferred language such as en_US. The text data will be returned in the preferred language along with default English text.
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FindByDistrictParams defines parameters for FindByDistrict.
type FindByDistrictParams struct {
	DistrictId string `json:"district_id"`
	Date       string `json:"date"`

	// The locate code of the preferred language such as en_US. The text data will be returned in the preferred language along with default English text.
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// FindByPinParams defines parameters for FindByPin.
type FindByPinParams struct {
	Pincode string `json:"pincode"`
	Date    string `json:"date"`

	// The locate code of the preferred language such as en_US. The text data will be returned in the preferred language along with default English text.
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// ConfirmOTPJSONBody defines parameters for ConfirmOTP.
type ConfirmOTPJSONBody struct {

	// SHA256 of the OTP
	Otp   *string `json:"otp,omitempty"`
	TxnId *string `json:"txnId,omitempty"`
}

// GenerateOTPJSONBody defines parameters for GenerateOTP.
type GenerateOTPJSONBody struct {
	Mobile *string `json:"mobile,omitempty"`
}

// DownloadParams defines parameters for Download.
type DownloadParams struct {
	BeneficiaryReferenceId string `json:"beneficiary_reference_id"`
}

// ConfirmOTPJSONRequestBody defines body for ConfirmOTP for application/json ContentType.
type ConfirmOTPJSONRequestBody ConfirmOTPJSONBody

// GenerateOTPJSONRequestBody defines body for GenerateOTP for application/json ContentType.
type GenerateOTPJSONRequestBody GenerateOTPJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Districts request
	Districts(ctx context.Context, stateId string, params *DistrictsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// States request
	States(ctx context.Context, params *StatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CalendarByDistrict request
	CalendarByDistrict(ctx context.Context, params *CalendarByDistrictParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CalendarByPin request
	CalendarByPin(ctx context.Context, params *CalendarByPinParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindByDistrict request
	FindByDistrict(ctx context.Context, params *FindByDistrictParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindByPin request
	FindByPin(ctx context.Context, params *FindByPinParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfirmOTP request  with any body
	ConfirmOTPWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConfirmOTP(ctx context.Context, body ConfirmOTPJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateOTP request  with any body
	GenerateOTPWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateOTP(ctx context.Context, body GenerateOTPJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Download request
	Download(ctx context.Context, params *DownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Districts(ctx context.Context, stateId string, params *DistrictsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDistrictsRequest(c.Server, stateId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) States(ctx context.Context, params *StatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CalendarByDistrict(ctx context.Context, params *CalendarByDistrictParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCalendarByDistrictRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CalendarByPin(ctx context.Context, params *CalendarByPinParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCalendarByPinRequest(c.Server, params)

	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindByDistrict(ctx context.Context, params *FindByDistrictParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindByDistrictRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindByPin(ctx context.Context, params *FindByPinParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindByPinRequest(c.Server, params)
	fmt.Println(req.URL)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmOTPWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmOTPRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmOTP(ctx context.Context, body ConfirmOTPJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmOTPRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateOTPWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateOTPRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateOTP(ctx context.Context, body GenerateOTPJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateOTPRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Download(ctx context.Context, params *DownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDistrictsRequest generates requests for Districts
func NewDistrictsRequest(server string, stateId string, params *DistrictsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "state_id", runtime.ParamLocationPath, stateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/admin/location/districts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewStatesRequest generates requests for States
func NewStatesRequest(server string, params *StatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/admin/location/states")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewCalendarByDistrictRequest generates requests for CalendarByDistrict
func NewCalendarByDistrictRequest(server string, params *CalendarByDistrictParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/appointment/sessions/public/calendarByDistrict")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "district_id", runtime.ParamLocationQuery, params.DistrictId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, params.Date); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewCalendarByPinRequest generates requests for CalendarByPin
func NewCalendarByPinRequest(server string, params *CalendarByPinParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/appointment/sessions/public/calendarByPin")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pincode", runtime.ParamLocationQuery, params.Pincode); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, params.Date); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}
	req.Header.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36 Edg/90.0.818.56")
	return req, nil
}

// NewFindByDistrictRequest generates requests for FindByDistrict
func NewFindByDistrictRequest(server string, params *FindByDistrictParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/appointment/sessions/public/findByDistrict")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "district_id", runtime.ParamLocationQuery, params.DistrictId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, params.Date); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewFindByPinRequest generates requests for FindByPin
func NewFindByPinRequest(server string, params *FindByPinParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/appointment/sessions/public/findByPin")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pincode", runtime.ParamLocationQuery, params.Pincode); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, params.Date); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewConfirmOTPRequest calls the generic ConfirmOTP builder with application/json body
func NewConfirmOTPRequest(server string, body ConfirmOTPJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConfirmOTPRequestWithBody(server, "application/json", bodyReader)
}

// NewConfirmOTPRequestWithBody generates requests for ConfirmOTP with any type of body
func NewConfirmOTPRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/auth/public/confirmOTP")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateOTPRequest calls the generic GenerateOTP builder with application/json body
func NewGenerateOTPRequest(server string, body GenerateOTPJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateOTPRequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateOTPRequestWithBody generates requests for GenerateOTP with any type of body
func NewGenerateOTPRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/auth/public/generateOTP")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadRequest generates requests for Download
func NewDownloadRequest(server string, params *DownloadParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/registration/certificate/public/download")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "beneficiary_reference_id", runtime.ParamLocationQuery, params.BeneficiaryReferenceId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// Districts request
	DistrictsWithResponse(ctx context.Context, stateId string, params *DistrictsParams, reqEditors ...RequestEditorFn) (*DistrictsResponse, error)

	// States request
	StatesWithResponse(ctx context.Context, params *StatesParams, reqEditors ...RequestEditorFn) (*StatesResponse, error)

	// CalendarByDistrict request
	CalendarByDistrictWithResponse(ctx context.Context, params *CalendarByDistrictParams, reqEditors ...RequestEditorFn) (*CalendarByDistrictResponse, error)

	// CalendarByPin request
	CalendarByPinWithResponse(ctx context.Context, params *CalendarByPinParams, reqEditors ...RequestEditorFn) (*CalendarByPinResponse, error)

	// FindByDistrict request
	FindByDistrictWithResponse(ctx context.Context, params *FindByDistrictParams, reqEditors ...RequestEditorFn) (*FindByDistrictResponse, error)

	// FindByPin request
	FindByPinWithResponse(ctx context.Context, params *FindByPinParams, reqEditors ...RequestEditorFn) (*FindByPinResponse, error)

	// ConfirmOTP request  with any body
	ConfirmOTPWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfirmOTPResponse, error)

	ConfirmOTPWithResponse(ctx context.Context, body ConfirmOTPJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfirmOTPResponse, error)

	// GenerateOTP request  with any body
	GenerateOTPWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateOTPResponse, error)

	GenerateOTPWithResponse(ctx context.Context, body GenerateOTPJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateOTPResponse, error)

	// Download request
	DownloadWithResponse(ctx context.Context, params *DownloadParams, reqEditors ...RequestEditorFn) (*DownloadResponse, error)
}

type DistrictsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Districts *[]struct {
			DistrictId   float32 `json:"district_id"`
			DistrictName string  `json:"district_name"`

			// District name in preferred language as specified in Accept-Language header parameter.
			DistrictNameL *string  `json:"district_name_l,omitempty"`
			StateId       *float32 `json:"state_id,omitempty"`
		} `json:"districts,omitempty"`

		// Time in hours to cache the data. Client applications can use this data for this many number of hours before calling this API again.
		Ttl *float32 `json:"ttl,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DistrictsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DistrictsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		States *[]struct {
			StateId   float32 `json:"state_id"`
			StateName string  `json:"state_name"`

			// State name in preferred language as specified in Accept-Language header parameter.
			StateNameL *string `json:"state_name_l,omitempty"`
		} `json:"states,omitempty"`

		// Time in hours to cache the data. Client applications can use this data for this many number of hours before calling this API again.
		Ttl *float32 `json:"ttl,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CalendarByDistrictResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Centers *SessionCalendarEntriesSchema `json:"centers,omitempty"`
	}
	JSON400 *struct {
		Error     *string `json:"error,omitempty"`
		ErrorCode *string `json:"errorCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CalendarByDistrictResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CalendarByDistrictResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CalendarByPinResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Centers *SessionCalendarEntriesSchema `json:"centers,omitempty"`
	}
	JSON400 *struct {
		Error     *string `json:"error,omitempty"`
		ErrorCode *string `json:"errorCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CalendarByPinResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CalendarByPinResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindByDistrictResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Sessions *SessionsSchema `json:"sessions,omitempty"`
	}
	JSON400 *struct {
		Error     *string `json:"error,omitempty"`
		ErrorCode *string `json:"errorCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FindByDistrictResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindByDistrictResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindByPinResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Sessions *SessionsSchema `json:"sessions,omitempty"`
	}
	JSON400 *struct {
		Error     *string `json:"error,omitempty"`
		ErrorCode *string `json:"errorCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FindByPinResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindByPinResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmOTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Token *string `json:"token,omitempty"`
	}
	JSON400 *struct {
		Error     *string `json:"error,omitempty"`
		ErrorCode *string `json:"errorCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ConfirmOTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmOTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateOTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		TxnId *string `json:"txnId,omitempty"`
	}
	JSON400 *struct {
		Error     *string `json:"error,omitempty"`
		ErrorCode *string `json:"errorCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GenerateOTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateOTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Error     *string `json:"error,omitempty"`
		ErrorCode *string `json:"errorCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DownloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DistrictsWithResponse request returning *DistrictsResponse
func (c *ClientWithResponses) DistrictsWithResponse(ctx context.Context, stateId string, params *DistrictsParams, reqEditors ...RequestEditorFn) (*DistrictsResponse, error) {
	rsp, err := c.Districts(ctx, stateId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDistrictsResponse(rsp)
}

// StatesWithResponse request returning *StatesResponse
func (c *ClientWithResponses) StatesWithResponse(ctx context.Context, params *StatesParams, reqEditors ...RequestEditorFn) (*StatesResponse, error) {
	rsp, err := c.States(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatesResponse(rsp)
}

// CalendarByDistrictWithResponse request returning *CalendarByDistrictResponse
func (c *ClientWithResponses) CalendarByDistrictWithResponse(ctx context.Context, params *CalendarByDistrictParams, reqEditors ...RequestEditorFn) (*CalendarByDistrictResponse, error) {
	rsp, err := c.CalendarByDistrict(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCalendarByDistrictResponse(rsp)
}

// CalendarByPinWithResponse request returning *CalendarByPinResponse
func (c *ClientWithResponses) CalendarByPinWithResponse(ctx context.Context, params *CalendarByPinParams, reqEditors ...RequestEditorFn) (*CalendarByPinResponse, error) {
	rsp, err := c.CalendarByPin(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCalendarByPinResponse(rsp)
}

// FindByDistrictWithResponse request returning *FindByDistrictResponse
func (c *ClientWithResponses) FindByDistrictWithResponse(ctx context.Context, params *FindByDistrictParams, reqEditors ...RequestEditorFn) (*FindByDistrictResponse, error) {
	rsp, err := c.FindByDistrict(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindByDistrictResponse(rsp)
}

// FindByPinWithResponse request returning *FindByPinResponse
func (c *ClientWithResponses) FindByPinWithResponse(ctx context.Context, params *FindByPinParams, reqEditors ...RequestEditorFn) (*FindByPinResponse, error) {
	rsp, err := c.FindByPin(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindByPinResponse(rsp)
}

// ConfirmOTPWithBodyWithResponse request with arbitrary body returning *ConfirmOTPResponse
func (c *ClientWithResponses) ConfirmOTPWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfirmOTPResponse, error) {
	rsp, err := c.ConfirmOTPWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmOTPResponse(rsp)
}

func (c *ClientWithResponses) ConfirmOTPWithResponse(ctx context.Context, body ConfirmOTPJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfirmOTPResponse, error) {
	rsp, err := c.ConfirmOTP(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmOTPResponse(rsp)
}

// GenerateOTPWithBodyWithResponse request with arbitrary body returning *GenerateOTPResponse
func (c *ClientWithResponses) GenerateOTPWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateOTPResponse, error) {
	rsp, err := c.GenerateOTPWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateOTPResponse(rsp)
}

func (c *ClientWithResponses) GenerateOTPWithResponse(ctx context.Context, body GenerateOTPJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateOTPResponse, error) {
	rsp, err := c.GenerateOTP(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateOTPResponse(rsp)
}

// DownloadWithResponse request returning *DownloadResponse
func (c *ClientWithResponses) DownloadWithResponse(ctx context.Context, params *DownloadParams, reqEditors ...RequestEditorFn) (*DownloadResponse, error) {
	rsp, err := c.Download(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadResponse(rsp)
}

// ParseDistrictsResponse parses an HTTP response from a DistrictsWithResponse call
func ParseDistrictsResponse(rsp *http.Response) (*DistrictsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DistrictsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Districts *[]struct {
				DistrictId   float32 `json:"district_id"`
				DistrictName string  `json:"district_name"`

				// District name in preferred language as specified in Accept-Language header parameter.
				DistrictNameL *string  `json:"district_name_l,omitempty"`
				StateId       *float32 `json:"state_id,omitempty"`
			} `json:"districts,omitempty"`

			// Time in hours to cache the data. Client applications can use this data for this many number of hours before calling this API again.
			Ttl *float32 `json:"ttl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (examples) unsupported

	}

	return response, nil
}

// ParseStatesResponse parses an HTTP response from a StatesWithResponse call
func ParseStatesResponse(rsp *http.Response) (*StatesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &StatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			States *[]struct {
				StateId   float32 `json:"state_id"`
				StateName string  `json:"state_name"`

				// State name in preferred language as specified in Accept-Language header parameter.
				StateNameL *string `json:"state_name_l,omitempty"`
			} `json:"states,omitempty"`

			// Time in hours to cache the data. Client applications can use this data for this many number of hours before calling this API again.
			Ttl *float32 `json:"ttl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (examples) unsupported

	}

	return response, nil
}

// ParseCalendarByDistrictResponse parses an HTTP response from a CalendarByDistrictWithResponse call
func ParseCalendarByDistrictResponse(rsp *http.Response) (*CalendarByDistrictResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CalendarByDistrictResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Centers *SessionCalendarEntriesSchema `json:"centers,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error     *string `json:"error,omitempty"`
			ErrorCode *string `json:"errorCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCalendarByPinResponse parses an HTTP response from a CalendarByPinWithResponse call
func ParseCalendarByPinResponse(rsp *http.Response) (*CalendarByPinResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CalendarByPinResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Centers *SessionCalendarEntriesSchema `json:"centers,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error     *string `json:"error,omitempty"`
			ErrorCode *string `json:"errorCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseFindByDistrictResponse parses an HTTP response from a FindByDistrictWithResponse call
func ParseFindByDistrictResponse(rsp *http.Response) (*FindByDistrictResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &FindByDistrictResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Sessions *SessionsSchema `json:"sessions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error     *string `json:"error,omitempty"`
			ErrorCode *string `json:"errorCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseFindByPinResponse parses an HTTP response from a FindByPinWithResponse call
func ParseFindByPinResponse(rsp *http.Response) (*FindByPinResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &FindByPinResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Sessions *SessionsSchema `json:"sessions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error     *string `json:"error,omitempty"`
			ErrorCode *string `json:"errorCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseConfirmOTPResponse parses an HTTP response from a ConfirmOTPWithResponse call
func ParseConfirmOTPResponse(rsp *http.Response) (*ConfirmOTPResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ConfirmOTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Token *string `json:"token,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error     *string `json:"error,omitempty"`
			ErrorCode *string `json:"errorCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGenerateOTPResponse parses an HTTP response from a GenerateOTPWithResponse call
func ParseGenerateOTPResponse(rsp *http.Response) (*GenerateOTPResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GenerateOTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			TxnId *string `json:"txnId,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error     *string `json:"error,omitempty"`
			ErrorCode *string `json:"errorCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDownloadResponse parses an HTTP response from a DownloadWithResponse call
func ParseDownloadResponse(rsp *http.Response) (*DownloadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DownloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error     *string `json:"error,omitempty"`
			ErrorCode *string `json:"errorCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}
